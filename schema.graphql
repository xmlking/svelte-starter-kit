schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input ListUniversitiesInput {
  country: String
  name: String
}

type ListUniversitiesOutput {
  alpha_two_code: String
  country: String
  domains: [String!]!
  name: String
  stateprovince: String
  web_pages: [String!]!
}

input SearchRestroomsInput {
  city: String
  limit: Int
  offset: Int
  page: Int
}

type SearchRestroomsOutput {
  accessible: Boolean
  approved: Boolean
  changing_table: Boolean
  city: String
  comment: String
  country: String
  created_at: String
  directions: String
  downvote: Int
  edit_id: Int
  id: Int
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  unisex: Boolean
  updated_at: String
  upvote: Int
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""action type"""
type action {
  description: String!
  value: String!
}

"""
aggregated selection of "action"
"""
type action_aggregate {
  aggregate: action_aggregate_fields
  nodes: [action!]!
}

"""
aggregate fields of "action"
"""
type action_aggregate_fields {
  count(columns: [action_select_column!], distinct: Boolean): Int!
  max: action_max_fields
  min: action_min_fields
}

"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input action_bool_exp {
  _and: [action_bool_exp!]
  _not: action_bool_exp
  _or: [action_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "action"
"""
enum action_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  action_pkey
}

enum action_enum {
  """BLOCK"""
  block

  """CALLOUT_INSPECTION"""
  callout_inspection

  """CALLOUT_TERMINATING"""
  callout_terminating

  """CALLOUT_UNKNOWN"""
  callout_unknown

  """PERMIT"""
  permit
}

"""
Boolean expression to compare columns of type "action_enum". All fields are combined with logical 'AND'.
"""
input action_enum_comparison_exp {
  _eq: action_enum
  _in: [action_enum!]
  _is_null: Boolean
  _neq: action_enum
  _nin: [action_enum!]
}

"""
input type for inserting data into table "action"
"""
input action_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type action_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type action_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "action"
"""
type action_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [action!]!
}

"""
on_conflict condition type for table "action"
"""
input action_on_conflict {
  constraint: action_constraint!
  update_columns: [action_update_column!]! = []
  where: action_bool_exp
}

"""Ordering options when selecting data from "action"."""
input action_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: action"""
input action_pk_columns_input {
  value: String!
}

"""
select columns of table "action"
"""
enum action_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "action"
"""
input action_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "action"
"""
input action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input action_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "action"
"""
enum action_update_column {
  """column name"""
  description

  """column name"""
  value
}

input action_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: action_set_input

  """filter the rows which have to be updated"""
  where: action_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""device to pool bridge table """
type device_pool {
  createdAt: timestamptz!
  createdBy: String!

  """An object relationship"""
  device: devices!
  deviceId: uuid!
  id: uuid!

  """An object relationship"""
  pool: pools!
  poolId: uuid!
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
aggregated selection of "device_pool"
"""
type device_pool_aggregate {
  aggregate: device_pool_aggregate_fields
  nodes: [device_pool!]!
}

input device_pool_aggregate_bool_exp {
  count: device_pool_aggregate_bool_exp_count
}

input device_pool_aggregate_bool_exp_count {
  arguments: [device_pool_select_column!]
  distinct: Boolean
  filter: device_pool_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "device_pool"
"""
type device_pool_aggregate_fields {
  count(columns: [device_pool_select_column!], distinct: Boolean): Int!
  max: device_pool_max_fields
  min: device_pool_min_fields
}

"""
order by aggregate values of table "device_pool"
"""
input device_pool_aggregate_order_by {
  count: order_by
  max: device_pool_max_order_by
  min: device_pool_min_order_by
}

"""
input type for inserting array relation for remote table "device_pool"
"""
input device_pool_arr_rel_insert_input {
  data: [device_pool_insert_input!]!

  """upsert condition"""
  on_conflict: device_pool_on_conflict
}

"""
Boolean expression to filter rows from the table "device_pool". All fields are combined with a logical 'AND'.
"""
input device_pool_bool_exp {
  _and: [device_pool_bool_exp!]
  _not: device_pool_bool_exp
  _or: [device_pool_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  device: devices_bool_exp
  deviceId: uuid_comparison_exp
  id: uuid_comparison_exp
  pool: pools_bool_exp
  poolId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "device_pool"
"""
enum device_pool_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  device_pool_pkey

  """
  unique or primary key constraint on columns "pool_id", "device_id"
  """
  device_pool_pool_id_device_id_key
}

"""
input type for inserting data into table "device_pool"
"""
input device_pool_insert_input {
  createdAt: timestamptz
  createdBy: String
  device: devices_obj_rel_insert_input
  deviceId: uuid
  id: uuid
  pool: pools_obj_rel_insert_input
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""aggregate max on columns"""
type device_pool_max_fields {
  createdAt: timestamptz
  createdBy: String
  deviceId: uuid
  id: uuid
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
order by max() on columns of table "device_pool"
"""
input device_pool_max_order_by {
  createdAt: order_by
  createdBy: order_by
  deviceId: order_by
  id: order_by
  poolId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type device_pool_min_fields {
  createdAt: timestamptz
  createdBy: String
  deviceId: uuid
  id: uuid
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
order by min() on columns of table "device_pool"
"""
input device_pool_min_order_by {
  createdAt: order_by
  createdBy: order_by
  deviceId: order_by
  id: order_by
  poolId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "device_pool"
"""
type device_pool_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [device_pool!]!
}

"""
on_conflict condition type for table "device_pool"
"""
input device_pool_on_conflict {
  constraint: device_pool_constraint!
  update_columns: [device_pool_update_column!]! = []
  where: device_pool_bool_exp
}

"""Ordering options when selecting data from "device_pool"."""
input device_pool_order_by {
  createdAt: order_by
  createdBy: order_by
  device: devices_order_by
  deviceId: order_by
  id: order_by
  pool: pools_order_by
  poolId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: device_pool"""
input device_pool_pk_columns_input {
  id: uuid!
}

"""
select columns of table "device_pool"
"""
enum device_pool_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deviceId

  """column name"""
  id

  """column name"""
  poolId

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "device_pool"
"""
input device_pool_set_input {
  createdAt: timestamptz
  createdBy: String
  deviceId: uuid
  id: uuid
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
Streaming cursor of the table "device_pool"
"""
input device_pool_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: device_pool_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input device_pool_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: String
  deviceId: uuid
  id: uuid
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "device_pool"
"""
enum device_pool_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deviceId

  """column name"""
  id

  """column name"""
  poolId

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input device_pool_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: device_pool_set_input

  """filter the rows which have to be updated"""
  where: device_pool_bool_exp!
}

"""devices metadata"""
type devices {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  description: String

  """An array relationship"""
  device_pools(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): [device_pool!]!

  """An aggregate relationship"""
  device_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): device_pool_aggregate!
  displayName: String!
  id: uuid!
  ip: String!
  organization: organization_enum!
  tags: _text
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
aggregated selection of "devices"
"""
type devices_aggregate {
  aggregate: devices_aggregate_fields
  nodes: [devices!]!
}

"""
aggregate fields of "devices"
"""
type devices_aggregate_fields {
  count(columns: [devices_select_column!], distinct: Boolean): Int!
  max: devices_max_fields
  min: devices_min_fields
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input devices_bool_exp {
  _and: [devices_bool_exp!]
  _not: devices_bool_exp
  _or: [devices_bool_exp!]
  annotations: hstore_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  deletedAt: timestamptz_comparison_exp
  description: String_comparison_exp
  device_pools: device_pool_bool_exp
  device_pools_aggregate: device_pool_aggregate_bool_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  ip: String_comparison_exp
  organization: organization_enum_comparison_exp
  tags: _text_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "devices"
"""
enum devices_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  devices_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  devices_pkey
}

"""
input type for inserting data into table "devices"
"""
input devices_insert_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  device_pools: device_pool_arr_rel_insert_input
  displayName: String
  id: uuid
  ip: String
  organization: organization_enum
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""aggregate max on columns"""
type devices_max_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  ip: String
  updatedAt: timestamptz
  updatedBy: String
}

"""aggregate min on columns"""
type devices_min_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  ip: String
  updatedAt: timestamptz
  updatedBy: String
}

"""
response of any mutation on the table "devices"
"""
type devices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [devices!]!
}

input devices_not_in_pool_args {
  poolid: uuid
}

"""
input type for inserting object relation for remote table "devices"
"""
input devices_obj_rel_insert_input {
  data: devices_insert_input!

  """upsert condition"""
  on_conflict: devices_on_conflict
}

"""
on_conflict condition type for table "devices"
"""
input devices_on_conflict {
  constraint: devices_constraint!
  update_columns: [devices_update_column!]! = []
  where: devices_bool_exp
}

"""Ordering options when selecting data from "devices"."""
input devices_order_by {
  annotations: order_by
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  description: order_by
  device_pools_aggregate: device_pool_aggregate_order_by
  displayName: order_by
  id: order_by
  ip: order_by
  organization: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: devices"""
input devices_pk_columns_input {
  id: uuid!
}

"""
select columns of table "devices"
"""
enum devices_select_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "devices"
"""
input devices_set_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: organization_enum
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""
Streaming cursor of the table "devices"
"""
input devices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: devices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input devices_stream_cursor_value_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: organization_enum
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "devices"
"""
enum devices_update_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input devices_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: devices_set_input

  """filter the rows which have to be updated"""
  where: devices_bool_exp!
}

"""direction type"""
type direction {
  description: String!
  value: String!
}

"""
aggregated selection of "direction"
"""
type direction_aggregate {
  aggregate: direction_aggregate_fields
  nodes: [direction!]!
}

"""
aggregate fields of "direction"
"""
type direction_aggregate_fields {
  count(columns: [direction_select_column!], distinct: Boolean): Int!
  max: direction_max_fields
  min: direction_min_fields
}

"""
Boolean expression to filter rows from the table "direction". All fields are combined with a logical 'AND'.
"""
input direction_bool_exp {
  _and: [direction_bool_exp!]
  _not: direction_bool_exp
  _or: [direction_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "direction"
"""
enum direction_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  direction_pkey
}

enum direction_enum {
  """EGRESS"""
  egress

  """INGRESS"""
  ingress
}

"""
Boolean expression to compare columns of type "direction_enum". All fields are combined with logical 'AND'.
"""
input direction_enum_comparison_exp {
  _eq: direction_enum
  _in: [direction_enum!]
  _is_null: Boolean
  _neq: direction_enum
  _nin: [direction_enum!]
}

"""
input type for inserting data into table "direction"
"""
input direction_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type direction_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type direction_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "direction"
"""
type direction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [direction!]!
}

"""
on_conflict condition type for table "direction"
"""
input direction_on_conflict {
  constraint: direction_constraint!
  update_columns: [direction_update_column!]! = []
  where: direction_bool_exp
}

"""Ordering options when selecting data from "direction"."""
input direction_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: direction"""
input direction_pk_columns_input {
  value: String!
}

"""
select columns of table "direction"
"""
enum direction_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "direction"
"""
input direction_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "direction"
"""
input direction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: direction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input direction_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "direction"
"""
enum direction_update_column {
  """column name"""
  description

  """column name"""
  value
}

input direction_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: direction_set_input

  """filter the rows which have to be updated"""
  where: direction_bool_exp!
}

scalar hstore

"""
Boolean expression to compare columns of type "hstore". All fields are combined with logical 'AND'.
"""
input hstore_comparison_exp {
  _eq: hstore
  _gt: hstore
  _gte: hstore
  _in: [hstore!]
  _is_null: Boolean
  _lt: hstore
  _lte: hstore
  _neq: hstore
  _nin: [hstore!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "action"
  """
  delete_action(
    """filter the rows which have to be deleted"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  delete single row from the table: "action"
  """
  delete_action_by_pk(value: String!): action

  """
  delete data from the table: "device_pool"
  """
  delete_device_pool(
    """filter the rows which have to be deleted"""
    where: device_pool_bool_exp!
  ): device_pool_mutation_response

  """
  delete single row from the table: "device_pool"
  """
  delete_device_pool_by_pk(id: uuid!): device_pool

  """
  delete data from the table: "devices"
  """
  delete_devices(
    """filter the rows which have to be deleted"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  delete single row from the table: "devices"
  """
  delete_devices_by_pk(id: uuid!): devices

  """
  delete data from the table: "direction"
  """
  delete_direction(
    """filter the rows which have to be deleted"""
    where: direction_bool_exp!
  ): direction_mutation_response

  """
  delete single row from the table: "direction"
  """
  delete_direction_by_pk(value: String!): direction

  """
  delete data from the table: "organization"
  """
  delete_organization(
    """filter the rows which have to be deleted"""
    where: organization_bool_exp!
  ): organization_mutation_response

  """
  delete single row from the table: "organization"
  """
  delete_organization_by_pk(value: String!): organization

  """
  delete data from the table: "policies"
  """
  delete_policies(
    """filter the rows which have to be deleted"""
    where: policies_bool_exp!
  ): policies_mutation_response

  """
  delete single row from the table: "policies"
  """
  delete_policies_by_pk(id: uuid!): policies

  """
  delete data from the table: "pools"
  """
  delete_pools(
    """filter the rows which have to be deleted"""
    where: pools_bool_exp!
  ): pools_mutation_response

  """
  delete single row from the table: "pools"
  """
  delete_pools_by_pk(id: uuid!): pools

  """
  delete data from the table: "protocol"
  """
  delete_protocol(
    """filter the rows which have to be deleted"""
    where: protocol_bool_exp!
  ): protocol_mutation_response

  """
  delete single row from the table: "protocol"
  """
  delete_protocol_by_pk(value: String!): protocol

  """
  delete data from the table: "rules"
  """
  delete_rules(
    """filter the rows which have to be deleted"""
    where: rules_bool_exp!
  ): rules_mutation_response

  """
  delete single row from the table: "rules"
  """
  delete_rules_by_pk(id: uuid!): rules

  """
  delete data from the table: "subject_type"
  """
  delete_subject_type(
    """filter the rows which have to be deleted"""
    where: subject_type_bool_exp!
  ): subject_type_mutation_response

  """
  delete single row from the table: "subject_type"
  """
  delete_subject_type_by_pk(value: String!): subject_type

  """
  insert data into the table: "action"
  """
  insert_action(
    """the rows to be inserted"""
    objects: [action_insert_input!]!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action_mutation_response

  """
  insert a single row into the table: "action"
  """
  insert_action_one(
    """the row to be inserted"""
    object: action_insert_input!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action

  """
  insert data into the table: "device_pool"
  """
  insert_device_pool(
    """the rows to be inserted"""
    objects: [device_pool_insert_input!]!

    """upsert condition"""
    on_conflict: device_pool_on_conflict
  ): device_pool_mutation_response

  """
  insert a single row into the table: "device_pool"
  """
  insert_device_pool_one(
    """the row to be inserted"""
    object: device_pool_insert_input!

    """upsert condition"""
    on_conflict: device_pool_on_conflict
  ): device_pool

  """
  insert data into the table: "devices"
  """
  insert_devices(
    """the rows to be inserted"""
    objects: [devices_insert_input!]!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices_mutation_response

  """
  insert a single row into the table: "devices"
  """
  insert_devices_one(
    """the row to be inserted"""
    object: devices_insert_input!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices

  """
  insert data into the table: "direction"
  """
  insert_direction(
    """the rows to be inserted"""
    objects: [direction_insert_input!]!

    """upsert condition"""
    on_conflict: direction_on_conflict
  ): direction_mutation_response

  """
  insert a single row into the table: "direction"
  """
  insert_direction_one(
    """the row to be inserted"""
    object: direction_insert_input!

    """upsert condition"""
    on_conflict: direction_on_conflict
  ): direction

  """
  insert data into the table: "organization"
  """
  insert_organization(
    """the rows to be inserted"""
    objects: [organization_insert_input!]!

    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization_mutation_response

  """
  insert a single row into the table: "organization"
  """
  insert_organization_one(
    """the row to be inserted"""
    object: organization_insert_input!

    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization

  """
  insert data into the table: "policies"
  """
  insert_policies(
    """the rows to be inserted"""
    objects: [policies_insert_input!]!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies_mutation_response

  """
  insert a single row into the table: "policies"
  """
  insert_policies_one(
    """the row to be inserted"""
    object: policies_insert_input!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies

  """
  insert data into the table: "pools"
  """
  insert_pools(
    """the rows to be inserted"""
    objects: [pools_insert_input!]!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools_mutation_response

  """
  insert a single row into the table: "pools"
  """
  insert_pools_one(
    """the row to be inserted"""
    object: pools_insert_input!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools

  """
  insert data into the table: "protocol"
  """
  insert_protocol(
    """the rows to be inserted"""
    objects: [protocol_insert_input!]!

    """upsert condition"""
    on_conflict: protocol_on_conflict
  ): protocol_mutation_response

  """
  insert a single row into the table: "protocol"
  """
  insert_protocol_one(
    """the row to be inserted"""
    object: protocol_insert_input!

    """upsert condition"""
    on_conflict: protocol_on_conflict
  ): protocol

  """
  insert data into the table: "rules"
  """
  insert_rules(
    """the rows to be inserted"""
    objects: [rules_insert_input!]!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules_mutation_response

  """
  insert a single row into the table: "rules"
  """
  insert_rules_one(
    """the row to be inserted"""
    object: rules_insert_input!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules

  """
  insert data into the table: "subject_type"
  """
  insert_subject_type(
    """the rows to be inserted"""
    objects: [subject_type_insert_input!]!

    """upsert condition"""
    on_conflict: subject_type_on_conflict
  ): subject_type_mutation_response

  """
  insert a single row into the table: "subject_type"
  """
  insert_subject_type_one(
    """the row to be inserted"""
    object: subject_type_insert_input!

    """upsert condition"""
    on_conflict: subject_type_on_conflict
  ): subject_type

  """
  update data of the table: "action"
  """
  update_action(
    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input

    """filter the rows which have to be updated"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  update single row of the table: "action"
  """
  update_action_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input
    pk_columns: action_pk_columns_input!
  ): action

  """
  update multiples rows of table: "action"
  """
  update_action_many(
    """updates to execute, in order"""
    updates: [action_updates!]!
  ): [action_mutation_response]

  """
  update data of the table: "device_pool"
  """
  update_device_pool(
    """sets the columns of the filtered rows to the given values"""
    _set: device_pool_set_input

    """filter the rows which have to be updated"""
    where: device_pool_bool_exp!
  ): device_pool_mutation_response

  """
  update single row of the table: "device_pool"
  """
  update_device_pool_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: device_pool_set_input
    pk_columns: device_pool_pk_columns_input!
  ): device_pool

  """
  update multiples rows of table: "device_pool"
  """
  update_device_pool_many(
    """updates to execute, in order"""
    updates: [device_pool_updates!]!
  ): [device_pool_mutation_response]

  """
  update data of the table: "devices"
  """
  update_devices(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input

    """filter the rows which have to be updated"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  update single row of the table: "devices"
  """
  update_devices_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input
    pk_columns: devices_pk_columns_input!
  ): devices

  """
  update multiples rows of table: "devices"
  """
  update_devices_many(
    """updates to execute, in order"""
    updates: [devices_updates!]!
  ): [devices_mutation_response]

  """
  update data of the table: "direction"
  """
  update_direction(
    """sets the columns of the filtered rows to the given values"""
    _set: direction_set_input

    """filter the rows which have to be updated"""
    where: direction_bool_exp!
  ): direction_mutation_response

  """
  update single row of the table: "direction"
  """
  update_direction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: direction_set_input
    pk_columns: direction_pk_columns_input!
  ): direction

  """
  update multiples rows of table: "direction"
  """
  update_direction_many(
    """updates to execute, in order"""
    updates: [direction_updates!]!
  ): [direction_mutation_response]

  """
  update data of the table: "organization"
  """
  update_organization(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input

    """filter the rows which have to be updated"""
    where: organization_bool_exp!
  ): organization_mutation_response

  """
  update single row of the table: "organization"
  """
  update_organization_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input
    pk_columns: organization_pk_columns_input!
  ): organization

  """
  update multiples rows of table: "organization"
  """
  update_organization_many(
    """updates to execute, in order"""
    updates: [organization_updates!]!
  ): [organization_mutation_response]

  """
  update data of the table: "policies"
  """
  update_policies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input

    """filter the rows which have to be updated"""
    where: policies_bool_exp!
  ): policies_mutation_response

  """
  update single row of the table: "policies"
  """
  update_policies_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input
    pk_columns: policies_pk_columns_input!
  ): policies

  """
  update multiples rows of table: "policies"
  """
  update_policies_many(
    """updates to execute, in order"""
    updates: [policies_updates!]!
  ): [policies_mutation_response]

  """
  update data of the table: "pools"
  """
  update_pools(
    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input

    """filter the rows which have to be updated"""
    where: pools_bool_exp!
  ): pools_mutation_response

  """
  update single row of the table: "pools"
  """
  update_pools_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input
    pk_columns: pools_pk_columns_input!
  ): pools

  """
  update multiples rows of table: "pools"
  """
  update_pools_many(
    """updates to execute, in order"""
    updates: [pools_updates!]!
  ): [pools_mutation_response]

  """
  update data of the table: "protocol"
  """
  update_protocol(
    """sets the columns of the filtered rows to the given values"""
    _set: protocol_set_input

    """filter the rows which have to be updated"""
    where: protocol_bool_exp!
  ): protocol_mutation_response

  """
  update single row of the table: "protocol"
  """
  update_protocol_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: protocol_set_input
    pk_columns: protocol_pk_columns_input!
  ): protocol

  """
  update multiples rows of table: "protocol"
  """
  update_protocol_many(
    """updates to execute, in order"""
    updates: [protocol_updates!]!
  ): [protocol_mutation_response]

  """
  update data of the table: "rules"
  """
  update_rules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input

    """filter the rows which have to be updated"""
    where: rules_bool_exp!
  ): rules_mutation_response

  """
  update single row of the table: "rules"
  """
  update_rules_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input
    pk_columns: rules_pk_columns_input!
  ): rules

  """
  update multiples rows of table: "rules"
  """
  update_rules_many(
    """updates to execute, in order"""
    updates: [rules_updates!]!
  ): [rules_mutation_response]

  """
  update data of the table: "subject_type"
  """
  update_subject_type(
    """sets the columns of the filtered rows to the given values"""
    _set: subject_type_set_input

    """filter the rows which have to be updated"""
    where: subject_type_bool_exp!
  ): subject_type_mutation_response

  """
  update single row of the table: "subject_type"
  """
  update_subject_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subject_type_set_input
    pk_columns: subject_type_pk_columns_input!
  ): subject_type

  """
  update multiples rows of table: "subject_type"
  """
  update_subject_type_many(
    """updates to execute, in order"""
    updates: [subject_type_updates!]!
  ): [subject_type_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""organizations are enums"""
type organization {
  description: String!
  value: String!
}

"""
aggregated selection of "organization"
"""
type organization_aggregate {
  aggregate: organization_aggregate_fields
  nodes: [organization!]!
}

"""
aggregate fields of "organization"
"""
type organization_aggregate_fields {
  count(columns: [organization_select_column!], distinct: Boolean): Int!
  max: organization_max_fields
  min: organization_min_fields
}

"""
Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'.
"""
input organization_bool_exp {
  _and: [organization_bool_exp!]
  _not: organization_bool_exp
  _or: [organization_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "organization"
"""
enum organization_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  organization_pkey
}

enum organization_enum {
  """chinthagunta org"""
  chinthagunta

  """example org"""
  example
}

"""
Boolean expression to compare columns of type "organization_enum". All fields are combined with logical 'AND'.
"""
input organization_enum_comparison_exp {
  _eq: organization_enum
  _in: [organization_enum!]
  _is_null: Boolean
  _neq: organization_enum
  _nin: [organization_enum!]
}

"""
input type for inserting data into table "organization"
"""
input organization_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type organization_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type organization_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "organization"
"""
type organization_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization!]!
}

"""
on_conflict condition type for table "organization"
"""
input organization_on_conflict {
  constraint: organization_constraint!
  update_columns: [organization_update_column!]! = []
  where: organization_bool_exp
}

"""Ordering options when selecting data from "organization"."""
input organization_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: organization"""
input organization_pk_columns_input {
  value: String!
}

"""
select columns of table "organization"
"""
enum organization_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "organization"
"""
input organization_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "organization"
"""
input organization_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "organization"
"""
enum organization_update_column {
  """column name"""
  description

  """column name"""
  value
}

input organization_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_set_input

  """filter the rows which have to be updated"""
  where: organization_bool_exp!
}

"""
policies is a joint table to connect a Subject polymorphically  and a Rule
"""
type policies {
  active: Boolean!
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  id: uuid!
  organization: organization_enum!
  roleId: uuid!

  """An object relationship"""
  rule: rules!
  subjectDisplayName: String!
  subjectId: uuid!
  subjectSecondaryId: String!
  subjectType: subject_type_enum!
  updatedAt: timestamptz!
  updatedBy: String!
  validFrom: timestamptz!
  validTo: timestamptz
  weight: smallint!
}

"""
aggregated selection of "policies"
"""
type policies_aggregate {
  aggregate: policies_aggregate_fields
  nodes: [policies!]!
}

"""
aggregate fields of "policies"
"""
type policies_aggregate_fields {
  avg: policies_avg_fields
  count(columns: [policies_select_column!], distinct: Boolean): Int!
  max: policies_max_fields
  min: policies_min_fields
  stddev: policies_stddev_fields
  stddev_pop: policies_stddev_pop_fields
  stddev_samp: policies_stddev_samp_fields
  sum: policies_sum_fields
  var_pop: policies_var_pop_fields
  var_samp: policies_var_samp_fields
  variance: policies_variance_fields
}

"""aggregate avg on columns"""
type policies_avg_fields {
  weight: Float
}

"""
Boolean expression to filter rows from the table "policies". All fields are combined with a logical 'AND'.
"""
input policies_bool_exp {
  _and: [policies_bool_exp!]
  _not: policies_bool_exp
  _or: [policies_bool_exp!]
  active: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  deletedAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  organization: organization_enum_comparison_exp
  roleId: uuid_comparison_exp
  rule: rules_bool_exp
  subjectDisplayName: String_comparison_exp
  subjectId: uuid_comparison_exp
  subjectSecondaryId: String_comparison_exp
  subjectType: subject_type_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
  validFrom: timestamptz_comparison_exp
  validTo: timestamptz_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "policies"
"""
enum policies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  policies_pkey

  """
  unique or primary key constraint on columns "role_id", "subject_id", "organization", "subject_type"
  """
  policies_subject_id_subject_type_role_id_organization_key
}

"""
input type for incrementing numeric columns in table "policies"
"""
input policies_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "policies"
"""
input policies_insert_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  id: uuid
  organization: organization_enum
  roleId: uuid
  rule: rules_obj_rel_insert_input
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate max on columns"""
type policies_max_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  id: uuid
  roleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate min on columns"""
type policies_min_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  id: uuid
  roleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
response of any mutation on the table "policies"
"""
type policies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [policies!]!
}

"""
on_conflict condition type for table "policies"
"""
input policies_on_conflict {
  constraint: policies_constraint!
  update_columns: [policies_update_column!]! = []
  where: policies_bool_exp
}

"""Ordering options when selecting data from "policies"."""
input policies_order_by {
  active: order_by
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  id: order_by
  organization: order_by
  roleId: order_by
  rule: rules_order_by
  subjectDisplayName: order_by
  subjectId: order_by
  subjectSecondaryId: order_by
  subjectType: order_by
  updatedAt: order_by
  updatedBy: order_by
  validFrom: order_by
  validTo: order_by
  weight: order_by
}

"""primary key columns input for table: policies"""
input policies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "policies"
"""
enum policies_select_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  roleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

"""
input type for updating data in table "policies"
"""
input policies_set_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  id: uuid
  organization: organization_enum
  roleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate stddev on columns"""
type policies_stddev_fields {
  weight: Float
}

"""aggregate stddev_pop on columns"""
type policies_stddev_pop_fields {
  weight: Float
}

"""aggregate stddev_samp on columns"""
type policies_stddev_samp_fields {
  weight: Float
}

"""
Streaming cursor of the table "policies"
"""
input policies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: policies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input policies_stream_cursor_value_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  id: uuid
  organization: organization_enum
  roleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate sum on columns"""
type policies_sum_fields {
  weight: smallint
}

"""
update columns of table "policies"
"""
enum policies_update_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  roleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

input policies_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: policies_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: policies_set_input

  """filter the rows which have to be updated"""
  where: policies_bool_exp!
}

"""aggregate var_pop on columns"""
type policies_var_pop_fields {
  weight: Float
}

"""aggregate var_samp on columns"""
type policies_var_samp_fields {
  weight: Float
}

"""aggregate variance on columns"""
type policies_variance_fields {
  weight: Float
}

"""Device pools"""
type pools {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  description: String
  displayName: String!
  id: uuid!
  organization: organization_enum!

  """An array relationship"""
  pool_devices(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): [device_pool!]!

  """An aggregate relationship"""
  pool_devices_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): device_pool_aggregate!
  tags: _text
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
aggregated selection of "pools"
"""
type pools_aggregate {
  aggregate: pools_aggregate_fields
  nodes: [pools!]!
}

"""
aggregate fields of "pools"
"""
type pools_aggregate_fields {
  count(columns: [pools_select_column!], distinct: Boolean): Int!
  max: pools_max_fields
  min: pools_min_fields
}

"""
Boolean expression to filter rows from the table "pools". All fields are combined with a logical 'AND'.
"""
input pools_bool_exp {
  _and: [pools_bool_exp!]
  _not: pools_bool_exp
  _or: [pools_bool_exp!]
  annotations: hstore_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  deletedAt: timestamptz_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  organization: organization_enum_comparison_exp
  pool_devices: device_pool_bool_exp
  pool_devices_aggregate: device_pool_aggregate_bool_exp
  tags: _text_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "pools"
"""
enum pools_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  pools_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  pools_pkey
}

"""
input type for inserting data into table "pools"
"""
input pools_insert_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  organization: organization_enum
  pool_devices: device_pool_arr_rel_insert_input
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""aggregate max on columns"""
type pools_max_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""aggregate min on columns"""
type pools_min_fields {
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
response of any mutation on the table "pools"
"""
type pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pools!]!
}

"""
input type for inserting object relation for remote table "pools"
"""
input pools_obj_rel_insert_input {
  data: pools_insert_input!

  """upsert condition"""
  on_conflict: pools_on_conflict
}

"""
on_conflict condition type for table "pools"
"""
input pools_on_conflict {
  constraint: pools_constraint!
  update_columns: [pools_update_column!]! = []
  where: pools_bool_exp
}

"""Ordering options when selecting data from "pools"."""
input pools_order_by {
  annotations: order_by
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  description: order_by
  displayName: order_by
  id: order_by
  organization: order_by
  pool_devices_aggregate: device_pool_aggregate_order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: pools"""
input pools_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pools"
"""
enum pools_select_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "pools"
"""
input pools_set_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  organization: organization_enum
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""
Streaming cursor of the table "pools"
"""
input pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pools_stream_cursor_value_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  organization: organization_enum
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "pools"
"""
enum pools_update_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input pools_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: pools_set_input

  """filter the rows which have to be updated"""
  where: pools_bool_exp!
}

"""network protocol enum"""
type protocol {
  description: String!
  value: String!
}

"""
aggregated selection of "protocol"
"""
type protocol_aggregate {
  aggregate: protocol_aggregate_fields
  nodes: [protocol!]!
}

"""
aggregate fields of "protocol"
"""
type protocol_aggregate_fields {
  count(columns: [protocol_select_column!], distinct: Boolean): Int!
  max: protocol_max_fields
  min: protocol_min_fields
}

"""
Boolean expression to filter rows from the table "protocol". All fields are combined with a logical 'AND'.
"""
input protocol_bool_exp {
  _and: [protocol_bool_exp!]
  _not: protocol_bool_exp
  _or: [protocol_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "protocol"
"""
enum protocol_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  protocol_pkey
}

enum protocol_enum {
  """Any"""
  Any

  """ICMP"""
  ICMP

  """ICMPV6"""
  ICMPV6

  """IGMP"""
  IGMP

  """IP"""
  IP

  """IPV6"""
  IPV6

  """RM"""
  RM

  """TCP"""
  TCP

  """UDP"""
  UDP
}

"""
Boolean expression to compare columns of type "protocol_enum". All fields are combined with logical 'AND'.
"""
input protocol_enum_comparison_exp {
  _eq: protocol_enum
  _in: [protocol_enum!]
  _is_null: Boolean
  _neq: protocol_enum
  _nin: [protocol_enum!]
}

"""
input type for inserting data into table "protocol"
"""
input protocol_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type protocol_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type protocol_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "protocol"
"""
type protocol_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [protocol!]!
}

"""
on_conflict condition type for table "protocol"
"""
input protocol_on_conflict {
  constraint: protocol_constraint!
  update_columns: [protocol_update_column!]! = []
  where: protocol_bool_exp
}

"""Ordering options when selecting data from "protocol"."""
input protocol_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: protocol"""
input protocol_pk_columns_input {
  value: String!
}

"""
select columns of table "protocol"
"""
enum protocol_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "protocol"
"""
input protocol_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "protocol"
"""
input protocol_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: protocol_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input protocol_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "protocol"
"""
enum protocol_update_column {
  """column name"""
  description

  """column name"""
  value
}

input protocol_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: protocol_set_input

  """filter the rows which have to be updated"""
  where: protocol_bool_exp!
}

type query_root {
  """Universities API"""
  ListUniversities(arg1: ListUniversitiesInput!): [ListUniversitiesOutput]

  """Restrooms API"""
  SearchRestrooms(arg1: SearchRestroomsInput!): [SearchRestroomsOutput]

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """
  fetch data from the table: "device_pool"
  """
  device_pool(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): [device_pool!]!

  """
  fetch aggregated fields from the table: "device_pool"
  """
  device_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): device_pool_aggregate!

  """fetch data from the table: "device_pool" using primary key columns"""
  device_pool_by_pk(id: uuid!): device_pool

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch aggregated fields from the table: "devices"
  """
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  execute function "devices_not_in_pool" which returns "devices"
  """
  devices_not_in_pool(
    """
    input parameters for function "devices_not_in_pool"
    """
    args: devices_not_in_pool_args!

    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  execute function "devices_not_in_pool" and query aggregates on result of table type "devices"
  """
  devices_not_in_pool_aggregate(
    """
    input parameters for function "devices_not_in_pool_aggregate"
    """
    args: devices_not_in_pool_args!

    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!

  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(value: String!): organization

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """
  fetch aggregated fields from the table: "policies"
  """
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch aggregated fields from the table: "pools"
  """
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """
  fetch aggregated fields from the table: "rules"
  """
  rules_aggregate(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): rules_aggregate!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """
  fetch aggregated fields from the table: "subject_type"
  """
  subject_type_aggregate(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): subject_type_aggregate!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type
}

"""5-tuple firewalls rules"""
type rules {
  action: action_enum!
  annotations: hstore
  appId: String
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum!
  displayName: String!
  id: uuid!
  organization: organization_enum!
  protocol: protocol_enum!
  shared: Boolean!
  source: String
  sourcePort: String
  tags: _text
  updatedAt: timestamptz!
  updatedBy: String!
  weight: smallint!
}

"""
aggregated selection of "rules"
"""
type rules_aggregate {
  aggregate: rules_aggregate_fields
  nodes: [rules!]!
}

"""
aggregate fields of "rules"
"""
type rules_aggregate_fields {
  avg: rules_avg_fields
  count(columns: [rules_select_column!], distinct: Boolean): Int!
  max: rules_max_fields
  min: rules_min_fields
  stddev: rules_stddev_fields
  stddev_pop: rules_stddev_pop_fields
  stddev_samp: rules_stddev_samp_fields
  sum: rules_sum_fields
  var_pop: rules_var_pop_fields
  var_samp: rules_var_samp_fields
  variance: rules_variance_fields
}

"""aggregate avg on columns"""
type rules_avg_fields {
  weight: Float
}

"""
Boolean expression to filter rows from the table "rules". All fields are combined with a logical 'AND'.
"""
input rules_bool_exp {
  _and: [rules_bool_exp!]
  _not: rules_bool_exp
  _or: [rules_bool_exp!]
  action: action_enum_comparison_exp
  annotations: hstore_comparison_exp
  appId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  deletedAt: timestamptz_comparison_exp
  description: String_comparison_exp
  destination: String_comparison_exp
  destinationPort: String_comparison_exp
  direction: direction_enum_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  organization: organization_enum_comparison_exp
  protocol: protocol_enum_comparison_exp
  shared: Boolean_comparison_exp
  source: String_comparison_exp
  sourcePort: String_comparison_exp
  tags: _text_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "rules"
"""
enum rules_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  rules_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  rules_pkey
}

"""
input type for incrementing numeric columns in table "rules"
"""
input rules_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "rules"
"""
input rules_insert_input {
  action: action_enum
  annotations: hstore
  appId: String
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  organization: organization_enum
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""aggregate max on columns"""
type rules_max_fields {
  appId: String
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  displayName: String
  id: uuid
  source: String
  sourcePort: String
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""aggregate min on columns"""
type rules_min_fields {
  appId: String
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  displayName: String
  id: uuid
  source: String
  sourcePort: String
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""
response of any mutation on the table "rules"
"""
type rules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rules!]!
}

"""
input type for inserting object relation for remote table "rules"
"""
input rules_obj_rel_insert_input {
  data: rules_insert_input!

  """upsert condition"""
  on_conflict: rules_on_conflict
}

"""
on_conflict condition type for table "rules"
"""
input rules_on_conflict {
  constraint: rules_constraint!
  update_columns: [rules_update_column!]! = []
  where: rules_bool_exp
}

"""Ordering options when selecting data from "rules"."""
input rules_order_by {
  action: order_by
  annotations: order_by
  appId: order_by
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  description: order_by
  destination: order_by
  destinationPort: order_by
  direction: order_by
  displayName: order_by
  id: order_by
  organization: order_by
  protocol: order_by
  shared: order_by
  source: order_by
  sourcePort: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  weight: order_by
}

"""primary key columns input for table: rules"""
input rules_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rules"
"""
enum rules_select_column {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

"""
input type for updating data in table "rules"
"""
input rules_set_input {
  action: action_enum
  annotations: hstore
  appId: String
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  organization: organization_enum
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""aggregate stddev on columns"""
type rules_stddev_fields {
  weight: Float
}

"""aggregate stddev_pop on columns"""
type rules_stddev_pop_fields {
  weight: Float
}

"""aggregate stddev_samp on columns"""
type rules_stddev_samp_fields {
  weight: Float
}

"""
Streaming cursor of the table "rules"
"""
input rules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rules_stream_cursor_value_input {
  action: action_enum
  annotations: hstore
  appId: String
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  organization: organization_enum
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: _text
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""aggregate sum on columns"""
type rules_sum_fields {
  weight: smallint
}

"""
update columns of table "rules"
"""
enum rules_update_column {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

input rules_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rules_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rules_set_input

  """filter the rows which have to be updated"""
  where: rules_bool_exp!
}

"""aggregate var_pop on columns"""
type rules_var_pop_fields {
  weight: Float
}

"""aggregate var_samp on columns"""
type rules_var_samp_fields {
  weight: Float
}

"""aggregate variance on columns"""
type rules_variance_fields {
  weight: Float
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""Subject Type"""
type subject_type {
  description: String!
  value: String!
}

"""
aggregated selection of "subject_type"
"""
type subject_type_aggregate {
  aggregate: subject_type_aggregate_fields
  nodes: [subject_type!]!
}

"""
aggregate fields of "subject_type"
"""
type subject_type_aggregate_fields {
  count(columns: [subject_type_select_column!], distinct: Boolean): Int!
  max: subject_type_max_fields
  min: subject_type_min_fields
}

"""
Boolean expression to filter rows from the table "subject_type". All fields are combined with a logical 'AND'.
"""
input subject_type_bool_exp {
  _and: [subject_type_bool_exp!]
  _not: subject_type_bool_exp
  _or: [subject_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "subject_type"
"""
enum subject_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  subject_type_pkey
}

enum subject_type_enum {
  """DEVICE"""
  device

  """DEVICE_POOL"""
  device_pool

  """GROUP"""
  group

  """SERVICE_ACCOUNT"""
  service_account

  """USER"""
  user
}

"""
Boolean expression to compare columns of type "subject_type_enum". All fields are combined with logical 'AND'.
"""
input subject_type_enum_comparison_exp {
  _eq: subject_type_enum
  _in: [subject_type_enum!]
  _is_null: Boolean
  _neq: subject_type_enum
  _nin: [subject_type_enum!]
}

"""
input type for inserting data into table "subject_type"
"""
input subject_type_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type subject_type_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type subject_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "subject_type"
"""
type subject_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subject_type!]!
}

"""
on_conflict condition type for table "subject_type"
"""
input subject_type_on_conflict {
  constraint: subject_type_constraint!
  update_columns: [subject_type_update_column!]! = []
  where: subject_type_bool_exp
}

"""Ordering options when selecting data from "subject_type"."""
input subject_type_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: subject_type"""
input subject_type_pk_columns_input {
  value: String!
}

"""
select columns of table "subject_type"
"""
enum subject_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "subject_type"
"""
input subject_type_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "subject_type"
"""
input subject_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subject_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subject_type_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "subject_type"
"""
enum subject_type_update_column {
  """column name"""
  description

  """column name"""
  value
}

input subject_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: subject_type_set_input

  """filter the rows which have to be updated"""
  where: subject_type_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """
  fetch data from the table in a streaming manner: "action"
  """
  action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [action_stream_cursor_input]!

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch data from the table: "device_pool"
  """
  device_pool(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): [device_pool!]!

  """
  fetch aggregated fields from the table: "device_pool"
  """
  device_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pool_order_by!]

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): device_pool_aggregate!

  """fetch data from the table: "device_pool" using primary key columns"""
  device_pool_by_pk(id: uuid!): device_pool

  """
  fetch data from the table in a streaming manner: "device_pool"
  """
  device_pool_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [device_pool_stream_cursor_input]!

    """filter the rows returned"""
    where: device_pool_bool_exp
  ): [device_pool!]!

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch aggregated fields from the table: "devices"
  """
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  execute function "devices_not_in_pool" which returns "devices"
  """
  devices_not_in_pool(
    """
    input parameters for function "devices_not_in_pool"
    """
    args: devices_not_in_pool_args!

    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  execute function "devices_not_in_pool" and query aggregates on result of table type "devices"
  """
  devices_not_in_pool_aggregate(
    """
    input parameters for function "devices_not_in_pool_aggregate"
    """
    args: devices_not_in_pool_args!

    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [devices_stream_cursor_input]!

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """
  fetch data from the table in a streaming manner: "direction"
  """
  direction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [direction_stream_cursor_input]!

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!

  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(value: String!): organization

  """
  fetch data from the table in a streaming manner: "organization"
  """
  organization_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """
  fetch aggregated fields from the table: "policies"
  """
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """
  fetch data from the table in a streaming manner: "policies"
  """
  policies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [policies_stream_cursor_input]!

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch aggregated fields from the table: "pools"
  """
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table in a streaming manner: "pools"
  """
  pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pools_stream_cursor_input]!

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """
  fetch data from the table in a streaming manner: "protocol"
  """
  protocol_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [protocol_stream_cursor_input]!

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """
  fetch aggregated fields from the table: "rules"
  """
  rules_aggregate(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): rules_aggregate!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table in a streaming manner: "rules"
  """
  rules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rules_stream_cursor_input]!

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """
  fetch aggregated fields from the table: "subject_type"
  """
  subject_type_aggregate(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): subject_type_aggregate!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type

  """
  fetch data from the table in a streaming manner: "subject_type"
  """
  subject_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subject_type_stream_cursor_input]!

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
